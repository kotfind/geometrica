#set heading(numbering: "1.")
#show figure: set block(breakable: true)
#show raw: set block(breakable: false)

= ОБЩИЕ СВЕДЕНИЯ

Встроенный язык программирования системы Geometrica (далее Язык) совмещает в
себе элементы как императивного, так и функционального программирования. Имеет
сильную статическую типизацию.

Верхнеуровневые (top-level) конструкции языка являются императивными: они
выполняются последовательно, одна за другой, и могут удалять, добавлять и
изменять элементы чертежа. Они дают пользователю возможность интерактивно
работать с геометрическим рисунком.

Все вычисления внутри чертежа (например, арифметические операции с числами и
векторами, построения прямых по точкам и т.д.) задаются в функциональном стиле.
Это позволяет определить структуру чертежа и впоследствии легко пересчитывать
все его элементы.

= ЭЛЕМЕНТЫ ЯЗЫКА

Далее дано описание синтаксиса Языка на русском языке. Синтаксические элементы
выделены _курсивом_.

Более формальное объявление можно найти в исходном коде, в файле
`crates/parser/src/parser/mod.rs`. Парсер написан с использованием библиотеки
`peg` и схож с PEG грамматикой.

О процессе исполнения кода смотри "Пояснительную записку", гл. 3.2.4 "Крейт
Client".

== Скрипт

Скрипт на Языке состоит из _выражений_ (`Statement`; @statement), разделенных
пробельными символами#footnote[
    Имеются в виду символы `'\n'` (конец строки), `'\t'` (таб) и `' '` (пробел).
].

== Выражение (`Statement`) <statement>

Каждое _выражение_ (`Statement`) является либо _объявлением функции_
(`FunctionDefinition`; @function_definition), либо _объявлением значение_
(`ValueDefinition`; @value_definition), либо _вызовом команды_ (`Command`; @command).

== Вызов команды (`Command`) <command>

_Вызов команды_ состоит из _названия команды_, и _аргументов команды_,
разделенных пробельными символами.

_Названием команды_ является _идентификатор_ (`Ident`; @ident), к которому
последним символом дописан `!` (восклицательный знак).

_Аргументом команды_ может быть либо _идентификатор_, либо
_выражение_ (`Expr`; @expr).

=== Примеры

-
    ```
    set! x 10.0
    ```

-
    ```
    set! x (1.0 + 2.0)
    ```

-
    ```
    eval! (
        (x + y) / 2
    )
    ```

== Идентификатор (`Ident`) <ident>

_Идентификатором_ является непустая последовательность символов, где первый
символ может быть маленькой или большой латинской буквой или нижним
подчеркиванием (`[a-zA-Z_]`), а последующие могут быть всем вышеперечисленным
или цифрой (`[a-zA-Z0-9_]`).

_Идентификаторы_ используются для имен переменных, команд и функций.

== Объявление значение (`ValueDefinition`) <value_definition>

_Объявление значения_ состоит из _имени значения_, _типа значения_ (опционально)
и _тела значения_ (`Expr`; @expr).

_Имя значения_ является _идентификатором_ (`Ident`; @ident).

_Тип значения_ отделяется от имени символом `:` (двоеточие). Если тип не указан
явно, то он будет определен из _выражения_.

_Тело значения_ является _выражением_ (`Expr`; @expr) и отделяется знаком `=`
(равно). В _теле значения_ могу быть использованы определенные раннее переменные.

Рекурсивные объявления запрещены: переменная не может определяться сама через
себя. Переопределения запрещены: нельзя дважды определить одну и ту же
переменную (при этом можно обновить значение переменной, используя команду
`set!`).

=== Примеры

- Без явного указания типа:

    ```
    x = 1
    ```

- С явным указанием типа:

    ```
    y: int = 10
    ```

- Со сложным выражением в правой части:

    ```
    z = 1 + 1
    ```

- С другими переменными в правой части (`x`, `y` и `z` должны быть определены):

    ```
    w = (x + y) / 2 - z
    ```

== Объявление функции (`FunctionDefinition`) <function_definition>

_Объявление функции_ состоит из _имени функции_, _объявлений аргументов_,
разделенных пробелами, _возвращаемого типа_ и _тела функции_.

_Имя функции_ является идентификатором (`Ident`; @ident).

_Объявление аргумента_ состоит из _имени аргумента_ и его _типа_. _Тип_
отделяется символом `:` (двоеточие).

_Возвращаемый тип_ отделяется символами `->`.

_Тело функции_ является _выражением_ (`Expr`; @expr) и отделяется знаком `=`
(равно). В _теле функции_ из переменных могут быть использованы только аргументы
функции или переменные определенные внутри тела функции. Переменные,
определенные, вне функции использовать *нельзя*.

Возможна перегрузка функций: можно создать несколько функций одинаковыми
именами, но разными типами аргументов. Возможна рекурсия: функция может вызывать
саму себя. Переопределение функций запрещено.

=== Примеры

- Обычное объявление:

    ```
    avg a:real b:real -> real = (a + b) / 2
    ```

- Перегрузка:

    ```
    sum a:int b:int -> int = a + b
    sum a:real b:real -> real = a + b
    ```

== Выражение (`Expr`) <expr>

_Выражение_ (`Expr`) может быть одним из следующих:

- _Литерал_ (`Value`; @value)
- _Переменная_ (`Ident`; @ident)
- _Выражение_ `let` (`LetExpr`; @let_expr)
- _Условное выражение_ (`IfExpr`; @if_expr)
- _Вызов функции_ (`FuncCallExpr`; @func_call_expr)
- _Dot-нотация_ (@dot_notation)
- _Применение унарного оператора_ (`UnaryExpr`; @unary_expr)
- _Применение инфиксного оператора_ (`InfixExpr`; @infix_expr)
- _Преобразование типа_ (`AsExpr`; @as_expr)

=== Литерал (`Value`) <value>

Значения бывают следующих типов (после названия типа приведены примеры значений
этих типов):
- `bool`: `true`, `false`
- `int`: `-5`, `42`
- `real`: `10.0`, `-1.0`, `1e7`, `1.7e4`
- `str`: `"Hello, world!"`, `"Two\nlines"`, `"\"Quoted\""`
- `pt`: `pt 100.0 100.0`
- `line`: `line p1 p2`, где `p1` и `p2` --- переменные типа `pt`
- `circ`: `circ o r`, где `o` --- переменная типа `pt`, центр окружности. `r` ---
    переменная типа `real`, радиус окружности

Типы `bool`, `int`, `real` и `str` можно создать при помощи _литерала_. Для
`pt`, `line` и `circ` литералов не существует --- значения этих типов можно
получить, воспользовавшись соответствующими встроенными функциями (смотри
примеры выше и @builtin_functions).

Каждое значение также может быть пустым. Для создания пустого значения
используйте конструкцию `none <type>`. Например, `none pt`.

=== Выражение `let` (`LetExpr`) <let_expr>

_Выражение `let`_ состоит из _объявления переменных_, разделяемых запятыми , и
_тела выражения `let`_. Запятая после последнего _объявления_ также допустима.

_Объявление переменной_ в _выражении `let`_ аналогично обычному объявлению переменной.

_Тело выражения `let`_ является _выражением_ (`Expr`; @expr). В нем можно
использовать все переменные, которые уже были доступны, а также те, что были
объявлены в данном `let`.

==== Примеры

- Без внешних переменных:

    ```
    let
      x = 1,
      y = 2,
    in
      x + y
    ```

- С внешними переменными (пусть переменная `x` уже объявлена):

    ```
    let t = x^2 + x in t^2 - 10 * t + 7
    ```

=== Условное выражение (`IfExpr`) <if_expr>

_Условное выражение_ состоит из набора _веток_, разделенных запятыми, и _ветки
else_ (опционально). Запятая после последней _ветки_ также допустима.

_Ветка_ состоит из _условия_ -- выражения (`Expr`; @expr), типа `bool`,
и _значения_ -- выражения любого типа.

_Ветка else_ состоит из _значения_ -- выражения любого типа.

_Значения_ всех _веток_ (включая _ветку else_) должны иметь одинаковый тип.

Все ветки рассматриваются в порядке их следования. If возвращает значение первой
ветки, _условие_ которой равно `true`. Если все _условия_ равны `false`, то
возвращается _значение_ _ветки else_. Если _ветка else_ отсутствует, то
возвращается ошибка.

==== Примеры

- Без ветки else:

    ```
    if
        1 == 2 then "equals",
        1 < 2  then "less",
        2 > 1  then "greater",
    ```

- С веткой else:

    ```
    if
        1 == 2 then "equals",
        1 < 2  then "less",
        else        "greater"
    ```

=== Вызов функции (`FuncCallExpr`) <func_call_expr>

_Вызов функции_ состоит из _имени функции_ и её _аргументов_, разделенных
пробельными символами.

_Аргументом_ является выражение (`Expr`).

==== Примеры

-
    ```
    sum 1.0 2.0
    ```

-
    ```
    max (2 * x) (avg x 10)
    ```

=== Dot-нотация <dot_notation>

_Dot-нотация_ является альтернативным синтаксисом для вызова функции *с ровно одним
аргументом*. Она состоит из _аргумента_ и _имени функции_, определенных
также, как и при простом вызове функции.

Dot-нотация полезная для функций-`getter`-ов и для последовательного вызова
нескольких функций.

==== Примеры

Пусть `p` --- переменная типа `pt`, `l` --- переменная типа `line`, `x` ---
функция, возвращающая `x` координату точки, `p1` --- функция возвращающая первую
из двух точек, по которым была построена прямая.

-
    ```
    p.x
    ```

    Возвращает `x` координату точки `p`. Равносильно обычному вызову функции:
    ```
    x p
    ```

- Цепочка вызовов:

    ```
    l.p1.x
    ```

- Со сложным выражением:

    ```
    (pt 100.0 200.0).x
    ```

=== Применение унарного оператора (`UnaryExpr`) <unary_expr>

_Применение унарного оператора_ состоит из _унарного оператора_ и _выражения_.

@builtin_unary_operators содержит список всех _унарных операторов_.

==== Примеры

-
    ```
    -x
    ```

=== Применение инфиксного оператора (`InfixExpr`) <infix_expr>

_Применение унарного оператора_ состоит из _левого выражения_, _инфиксного оператора_
и _правого выражения_.

@builtin_binary_operators содержит список всех _бинарных операторов_.

==== Примеры

-
    ```
    x + y
    ```

-
    ```
    (10 * x + 7 * y)^2
    ```

=== Преобразование типа (`AsExpr`) <as_expr>

_Преобразование типа_ состоит из _выражения_ и _типа_.

_Выражение_ будет преобразовано в указанный _тип_, если это возможно. Иначе,
произойдет ошибка.

==== Примеры

-
    ```
    (x + y) as real
    ```

-
    ```
    100 as str
    ```

== Комментарии

_Комментарии_ могут быть помещены почти в любое место кода. Они бывают двух видов:
многострочные и однострочные. Однострочный комментарий может содержать любые
символы, кроме `'\n'` (конца строки); многострочный --- любые символы, кроме
последовательности `"*/"` (звездочка, слеш).

=== Примеры

- Однострочный:

    ```
    // Comment here
    ```

- Многострочный:

    ```
    /*
        There is a lot
        of text here!
        Isn't it?
    */
    ```

- В объявлении функции:

    ```
    // Being very verbose here:
    sum // <- this is a function name
        x /* first arg */: /* it's a type */ int
        y: int // second arg here!
    -> int // <- return type
    = x + y
    ```

= ВСТРОЕННЫЕ ЭЛЕМЕНТЫ

Здесь указан *минимальный* список встроенных элементов. Конкретная реализация
может расширять этот список. Для получения полного списка используйте функции
`list_func!` и `list_cmd!` (смотри @builtin_commands).

== Унарные операторы <builtin_unary_operators>

#figure(
    table(
        columns: 3,
        align: (
            center + horizon,
            left + horizon,
            center + horizon,
        ),

        table.header[*Оператор*][*Сигнатура*][*Операция*],

        `!`, `bool -> bool`, [Булево "НЕ"],

        table.cell(rowspan: 3, `-`),
        `int -> int`,
        table.cell(rowspan: 3, [Отрицание]),
        /* SPAN */ `real -> real`, /* SPAN */
        /* SPAN */ `pt -> pt`, /* SPAN */
    ),
    caption: [Встроенные унарные операторы],
)

== Бинарные операторы <builtin_binary_operators>

#figure(
    table(
        columns: 3,
        align: (
            center + horizon,
            left + horizon,
            center + horizon,
        ),

        table.header[*Оператор*][*Сигнатура*][*Операция*],

        table.cell(rowspan: 4, `+`),
        `int int -> int`,
        table.cell(rowspan: 4, [Сложение/\ конкатенация]),
        /* SPAN */ `real real -> real`, /* SPAN */
        /* SPAN */ `pt pt -> pt`, /* SPAN */
        /* SPAN */ `str str -> str`, /* SPAN */

        table.cell(rowspan: 3, `-`),
        `int int -> int`,
        table.cell(rowspan: 3, [Вычитание]),
        /* SPAN */ `real real -> real`, /* SPAN */
        /* SPAN */ `pt pt -> pt`, /* SPAN */

        table.cell(rowspan: 4, `*`),
        `int int -> int`,
        table.cell(rowspan: 4, [Умножение]),
        /* SPAN */ `real real -> real`, /* SPAN */
        /* SPAN */ `real pt -> pt`, /* SPAN */
        /* SPAN */ `pt real -> pt`, /* SPAN */

        table.cell(rowspan: 3, `/`),
        `int int -> int`,
        table.cell(rowspan: 3, [Деление]),
        /* SPAN */ `real real -> real`, /* SPAN */
        /* SPAN */ `pt real -> pt`, /* SPAN */

        table.cell(rowspan: 3, [`**`\ `^`]),
        `int int -> int`,
        table.cell(rowspan: 3, [Возведение\ в степень]),
        /* SPAN */ `real real -> real`, /* SPAN */
        /* SPAN */ `real int -> real`, /* SPAN */

        table.cell(rowspan: 2, `%`),
        `int int -> int`,
        table.cell(rowspan: 2, [Взятие\ остатка]),
        /* SPAN */ `real real -> real`, /* SPAN */

        table.cell(rowspan: 3, `<`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Меньше]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        table.cell(rowspan: 3, `>`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Больше]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        table.cell(rowspan: 3, `<=`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Меньше\ или\ равно]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        table.cell(rowspan: 3, `>=`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Больше\ или\ равно]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        table.cell(rowspan: 3, `==`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Равно]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        table.cell(rowspan: 3, `!=`),
        `int int -> bool`,
        table.cell(rowspan: 3, [Не равно]),
        /* SPAN */ `real real -> bool`, /* SPAN */
        /* SPAN */ `str str -> bool`, /* SPAN */

        `|`, `bool bool -> bool`, [Булево "ИЛИ"],

        `&`, `bool bool -> bool`, [Булево "И"],
    ),
    caption: [Встроенные бинарные операторы],
)

== Команды <builtin_commands>

#figure(
    table(
        columns: (auto, auto, 6cm),
        align: left + horizon,
        table.header[*Команда*][*Аргументы*][*Комментарий*],
        `get!`, `ident+`, [ Получить значение переменных ],
        `get_all!`, sym.emptyset, [ Получить значение всех переменных ],
        `eval!`, `expr+`, [ Вычислить значения выражений `expr+` ],
        `set!`,
        `ident expr`,
        [
            Установить значение переменной `ident`, равным значению
            выражения `expr`
        ],

        `rm!`, `ident+`, [Удалить переменные `ident+`],
        `list_cmd!`, sym.emptyset, [Вывести список всех команд],
        `list_func!`, sym.emptyset, [Вывести список всех функций],
    ),
    caption: [Встроенные команды],
)

== Функции <builtin_functions>


#figure(
    table(
        columns: (auto, auto, 6cm),
        align: left + horizon,
        table.header[*Функция*][*Сигнатура*][*Комментарий*],
        `dot`, `pt pt -> real`, [Скалярное произведение],
        `cross`, `pt pt -> real`, [Косое произведение],
        `pt`, `real real -> pt`, [Точка по двум координатам],
        `x`, `pt -> real`, [`x`-координата точки],
        `y`, `pt -> real`, [`y`-координата точки],
        `line`, `pt pt -> line`, [Прямая по двум точкам],
        `p1`, `line -> pt`, [Первая точка, по которой была построена прямая],
        `p2`, `line -> pt`, [Вторая точка, по которой была построена прямая],
        `a`,
        `line -> real`,
        [Коэффициент `a` в общем уравнении прямой: $a x + b y + c = 0$],

        `b`,
        `line -> real`,
        [Коэффициент `b` в общем уравнении прямой: $a x + b y + c = 0$],

        `c`,
        `line -> real`,
        [Коэффициент `c` в общем уравнении прямой: $a x + b y + c = 0$],

        `circ`, `pt real -> circ`, [Окружность по центру и радиусу],
        `o`, `circ -> pt`, [Центр окружности],
        `r`, `circ -> real`, [Радиус окружности],
    ),
    caption: [Встроенные функции],
)

= ПРИМЕР ЦЕЛЬНОЙ ПРОГРАММЫ

#let str_ref(lbl) = {
    let items = query(lbl)
    assert(items.len() == 1)
    let item = items.first()
    assert(item.kind == image)

    "Рис. " + item.counter.at(lbl).map(str).join(".")
}

#context raw(
    read("./code_example.geom")
        .replace(
            "__SCREENSHOT_1__",
            str_ref(label("screenshot_1")),
        )
        .replace(
            "__SCREENSHOT_2__",
            str_ref(label("screenshot_2")),
        ),
)

#grid(
    columns: (1fr,) * 2,
    align: horizon + center,
    [
        #figure(
            image(
                "screenshot_1.png",
                height: 5cm,
            ),
            caption: [Снимок экрана],
        ) <screenshot_1>
    ],
    [
        #figure(
            image(
                "screenshot_2.png",
                height: 5cm,
            ),
            caption: [Снимок экрана],
        ) <screenshot_2>
    ],
)
