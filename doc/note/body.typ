#import "@preview/diagraph:0.3.3"

#show figure.caption: body => block(width: 15cm, body)

= ВВЕДЕНИЕ

== Наименование программы

Наименование программы --- *"Система построение геометрических чертежей со
встроенным языком программирования и возможностью удаленного программного
управления"*

Наименование программы на английском языке --- *"Geometric Drawing System with a
Built-in Programming Language and a Remote Program Control Capability"*

Краткое наименование программы --- *"Geometrica"*

== Краткая характеристика области применения программы

"Geometrica" --- это десктоп-приложение, которое позволяет пользователю
строить и изменять геометрические чертежи, используя графический интерфейс
(GUI), интерфейс командной строки (CLI) или библиотеку для языка
программирования Rust.

== Документ(ы), на основании которых ведется разработка

Разработка ведётся на основании учебного плана подготовки бакалавров по
направлению 09.03.04 "Программная инженерия" и утвержденной академическим
руководителем программы темы курсового проекта.

== Наименование темы разработки

Наименование темы разработки: "Система построение геометрических чертежей со
встроенным языком программирования и возможностью удаленного программного
управления".

Условное обозначение темы разработки – "Geometrica".

= НАЗНАЧЕНИЕ И ОБЛАСТЬ ПРИМЕНЕНИЯ

== Функциональное назначение

Программный продукт позволяет пользователю строить и автоматически перестраивать
геометрические чертежи. Производить расчеты на основе построенного чертежа.

== Эксплуатационное назначение

Продукт состоит из трех исполняемых файлов для ОС Linux и одной библиотеки для
языка программирования Rust:
- Сервера;
- Графического (GUI) клиента;
- Клиента командной строки (CLI);
- Клиента-библиотеки (lib).

Целевой аудиторией являются:
- Школьники, изучающие геометрию (5--11 классы);
- Школьные учителя, преподающие геометрию (5--11 класс);
- Студенты ВУЗов, изучающие вычислительную геометрию;
- Преподаватели ВУЗов, преподающие вычислительную геометрию.

Продукт будет полезен как для проведения занятий, так и для индивидуальной
работы.

CLI- и lib-клиенты в первую очередь нацелены на студентов и преподавателей
ВУЗов. GUI клиент будет интересен всем представителям целевой аудитории.

= ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТИКИ

== Постановка задачи на разработку программы

Цель работы --- реализовать все компоненты описанной выше системы, а именно:
- Сервер;
- Графический (GUI) клиент;
- Клиент командной строки (CLI);
- Клиент-библиотеку (lib).

== Описание алгоритма и функционирования программы
// описание алгоритма и (или) функционирования программы с обоснованием выбора
// схемы алгоритма решения задачи, возможные взаимодействия программы с
// другими программами;

=== Краткое описание крейтов#footnote[
    *Крейт (crate)* единица компиляции в Rust. Ближайший аналог в других языках
    программирования --- пакет.
] и взаимодействия между ними

Программный продукт разделен на несколько крейтов:

- Клиентская сторона:

    - *GUI* --- графический клиент. Поставляется пользователю, как часть
        программного продукта.

    - *CLI* --- клиент командной строки. Поставляется пользователю, как часть
        программного продукта.

    - *Client* --- клиент-библиотека. Поставляется пользователю, как часть
        программного продукта, а также используется в реализации крейтов *CLI* и *GUI*.

    - *Parser* отвечает за парсинг встроенного языка программирования. Является
        частью внутренней реализации, пользователю *не* поставляется.

- Серверная сторона:

    - *Server* --- сервер. Поставляется пользователю, как часть программного
        продукта.

    - *Executor* выполняет основную часть вычислений. Является частью внутренней
        реализации, пользователю *не* поставляется.

- Общее:

    - *Types* содержит объявления структур, используемых как на серверной, так и
        на клиентской стороне.

Более подробное описание некоторых из крейтов содержится в последующих пунктах.

Отношения между крейтами можно увидеть на @crate_relations.

#figure(
    diagraph.render(
        read("./schema.dot"),
        height: 8cm,
    ),
    placement: auto,
    caption: [
        Взаимодействие между крейтами.

        #set align(left)

        Все крейты также зависят от крейта `Types`. Эти связи не изображены
        в целях упрощения рисунка.

        Бинарные крейты (binary crates) выделены *жирным*, крейты-библиотеки
        (library crates) выделены _курсивом_.

        Обычными стрелками показаны
        библиотечные зависимости, пунктирными --- зависимости других типов.
    ],
) <crate_relations>

=== Крейт Types

Крейт Types содержит в себе объявления некоторых струкур (и связанных с ними
функций и методов), используемых как серверной, так и клиентской сторонами.
Среди них:
- структуры, описывающие типы встроенного языка программирования: `Value`,
    `ValueType`, `Pt`, `Line` и д.р.;
- структуры, описывающие синтаксис встроенного языка программирования:
    `Statement`, `Definition`, `Expr` и д.р.;
- структуры, описывающие `api`: `api::items::get_all::Request`,
    `api::items::get_all::Response`, `api::set::Request`, `api::set::Response` и
    д.р.

Предполагается, что этот крейт должен быть настолько компактным, насколько
это возможно. С этой целью в нем применяется техника условной компиляции
(conditional compilation), благодаря которой часть функционала крейта можно не
компилировать, если в ней нет необходимости, что позволит уменьшить размер
результирующего файла, путем отключения ненужного кода и ненужных зависимостей.

=== Крейт Parser

Крейт Parser реализует логику, связанную с парсингом встроенного языка
программирования. Он предоставляет пользователю несколько методов для парсинга
тех или иных языковых конструкций: `script`, `expr`, `statement` и д.р., а также
трейт#footnote[
    Ближайшим аналогом *трейта (trait)* из Rust в других языка программирования
    является интерфейc.
] `ParseInto<T>` с аналогичным назначением.

Для парсинга используется библиотека `peg`.

=== Крейт Client

Крейт Client реализует логику клиентской стороны приложения.

Основной структурой данного крейта является `Client`. Он предоставляется набор
методов (`command`, `eval`, `get_all_items` и д.р.) для взаимодействия с
сервером.

=== Крейт GUI

Крейт GUI содержит реализацию графического клиента.

Он использует библиотеку `iced` для отрисовки интерфейса и крейт Client для
взаимодействия с сервером.

=== Крейт CLI

Крейт CLI содержит реализацию клиента командной строки.

Он может работать в нескольких режимах:
- *Скриптовый режим* будет запущен, если передать имя некоторого файла, в
    качестве аргумента командной строки. Тогда этот файл будет обработан, как
    скрипт на встроенном языке программирования. Результат выполнения скрипта
    будет напечатан на стандартный вывод.

- *Режим стандартного ввода* будет запущен, если передавать данные на
    стандартный ввод через `pipe`. Тогда входные данные будут обработаны, как код
    на встроенном языке программирования. Результат выполнения скрипта будет
    напечатан на стандартный вывод.

- *Интерактивный режим* будет запущен, если в остальных случаях (если не
    передавать аргументов командной строки и не использовать `pipe`).
    В этом режиме пользователь может интерактивно вводить код на встроенном
    языке программирования и сразу получать результат его выполнения.

=== Крейт Executor

Крейт Executor выполняет основную часть вычислений, а именно, исполняет код на
встроенном языке программирования и поддерживает нынешнее состояние чертежа.

Для хранения чертежа служит структура `Node` (вершина). Вершина может содержать
либо некоторое фиксированное значение; либо функцию и набор её аргументов
(список других вершин), на основе которых это значение можно вычислить. Вершина
также хранит список вершин, которые зависят от неё, --- это упрощает процесс
пересчета.

Процесс выполнения кода происходит следующим образом:
- Из строкового представления код парсится в `Vec<Statement>`. На этом этапе
    структурные преобразования минимальны. Структура `Statement` очень похожа на
    синтаксис встроенного языка.

- Далее возможно два случая:

    - Если очередное выражение (`Statement`) является командой (`Command`; то
        есть оно может менять структуру дерева), то оно обрабатывается особым
        образом. Например, команда `set` изменяет значение вершины, `eval`
        вычисляет значение выражения и т.д.

    - Иначе, если очередное выражение (`Statement`) является объявлением
        (`FunctionDefinition` или `ValueDefinition`), то в списке функций или
        вершин соответственно, создается новый элемент. Тело функции или значение
        выражения, представленное в виде `Expr`, обрабатывается описанным ниже
        образом (парсинг уже был выполнен, поэтому первый пункт в списке
        пропускается).

Процесс обработки `Expr` (также смотри /* TODO */):
- Из строкового представления выражение парсится в `Expr`. Сказанное выше про
    `Statement` верно и для `Expr`: структура `Expr` максимально приближена к
    синтаксису встроенного языка программирования. Это полезно, при выводе `Expr`
    на экран (превращении `Expr` обратно в строку).

- `Expr` компилируется в `CExpr` (от Compiled `Expr`). На этом этапе происходит
    разрешение имен переменных и функций, происходят упрощение структуры
    выражения. Так, если структура `Expr` похожа на синтаксис языка и удобна для ввода/
    вывода, то структура `CExpr` оптимизирована для простоты вычислений.

// TODO: написать про Expr -> CExpr, "server -- это фасад", conditional
// compilation в types

== Описание и обоснование выбора метода организации входных данных
// описание и обоснование выбора метода организации входных и выходных данных;

== Описание и обоснование выбора состава технических и программных средств
// описание и обоснование выбора состава технических и программных средств на
// основании проведенных расчетов и (или) анализов, распределение носителей
// данных, которые использует программа.

= ОЖИДАЕМЫЕ ТЕХНИКО-ЭКОНОМИЧЕСКИЕ ПОКАЗАТЕЛИ

== Предполагаемая потребность

== Сравнение с аналогичными решениями
